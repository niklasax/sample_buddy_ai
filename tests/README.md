# Sample Buddy AI Test Suite

This directory contains tests for the Sample Buddy AI audio sample manager application. These tests help ensure that core functionality continues to work properly as the codebase evolves.

## Test Organization

The test suite is organized into several categories:

1. **Basic Functionality Tests** (`test_basic_functionality.py`)
   - Tests the core classification functions
   - Verifies that both quick and deep classifiers work
   - Checks feature extraction and filename parsing

2. **Web Application Tests** (`test_web_app.py`)
   - Tests the Flask web application routes
   - Verifies file upload handling
   - Checks error handling for invalid inputs

3. **Similarity Search Tests** (`test_similarity_search.py`)
   - Tests the audio similarity search functionality
   - Verifies feature vector creation and comparison
   - Checks similarity ranking between samples

## Running Tests

### All Tests

To run all tests, use the test runner script:

```bash
python run_tests.py
```

### Specific Test Categories

You can run specific test categories by providing the category name:

```bash
python run_tests.py basic       # Basic functionality tests
python run_tests.py web         # Web application tests
python run_tests.py similarity  # Similarity search tests
```

### Using Python's unittest Directly

You can also run tests directly using Python's unittest module:

```bash
python -m unittest discover tests
```

Or run a specific test file:

```bash
python -m unittest tests/test_basic_functionality.py
```

## Test Sample Files

The tests use a minimal test audio file (`tests/test_samples/test_kick.wav`) that is automatically generated by the test runner. This ensures that the tests can run without requiring real audio files.

For more realistic testing, you can place actual audio samples in the `tests/test_samples` directory. If present, the tests will use these real samples instead of the minimal test file.

## Adding New Tests

When adding new features to Sample Buddy AI, consider adding corresponding tests to ensure that:

1. The new feature works as expected
2. The new feature doesn't break existing functionality
3. Edge cases and error conditions are handled properly

Follow the pattern in the existing test files, which use Python's `unittest` framework.